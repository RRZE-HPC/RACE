% SIAM Article Template
\documentclass[review,onefignum,onetabnum]{siamart171218}
\usepackage{booktabs}
\usepackage{graphicx,epstopdf} 
\usepackage[caption=false]{subfig} 
\usepackage{braket,amsfonts,amsopn} % <- Preamble
\usepackage{algorithmic}
 \Crefname{ALC@unique}{Line}{Lines}
 \usepackage{multirow}

\definecolor{amber}{rgb}{1.0, 0.49, 0.0}
\definecolor{carmine}{rgb}{0.59, 0.0, 0.09}
% Information that is shared between the article and the supplement
% (title and author information, macros, packages, etc.) goes into
% ex_shared.tex. If there is no supplement, this file can be included
% directly.

\input{ex_shared}

% Optional PDF information
\ifpdf
\hypersetup{
  pdftitle={RACE},
  pdfauthor={}
}
\fi

% The next statement enables references to information in the
% supplement. See the xr-hyperref package for details.

%\externaldocument{ex_supplement}

% FundRef data to be entered by SIAM
%<funding-group>
%<award-group>
%<funding-source>
%<named-content content-type="funder-name"> 
%</named-content> 
%<named-content content-type="funder-identifier"> 
%</named-content>
%</funding-source>
%<award-id> </award-id>
%</award-group>
%</funding-group>

\newcommand{\RACE}{RACE }
\newcommand{\RACEfull}{Recursive Algebraic Coloring Engine }
\newcommand{\DONE}{distance-$1$ }
\newcommand{\DTWO}{distance-$2$ }
\newcommand{\DK}{distance-$k$ }
\newcommand{\etal}{et al. }
\newcommand{\RSB}{RSB }
\newcommand{\SpMV}{SpMV }
\newcommand{\SymmSpmv}{SymmSpMV }
\newcommand{\SpMTV}{SpMTV }
\newcommand{\GS}{GS }
\newcommand{\KACZ}{KACZ }
\newcommand{\Intel}{Intel }
\newcommand{\AMD}{AMD }
\newcommand{\IVB}{Ivy-Bridge }
\newcommand{\BDW}{Broadwell }
\newcommand{\SKX}{Sky-Lake }
\newcommand{\NAP}{Naples }
\newcommand{\EPY}{Epyc }
\newcommand{\CRS}{CRS }
\newcommand{\MC}{MC }
\newcommand{\MCfull}{multi-coloring }
\newcommand{\ABMC}{ABMC }
\newcommand{\ABMCfull}{algebraic block multi-coloring }
\newcommand{\NNZR}{$N_{nzr}$ }
\newcommand{\NNZRSYMM}{$N_{nzr}^{symm}$ }
\newcommand{\NNZRmath}{N_{nzr} }
\newcommand{\NNZRmathSYMM}{N_{nzr}^{symm} }
\newcommand{\LIKWID}{LIKWID }
\newcommand{\likwidBench}{$likwid-bench$ }
\newcommand{\LLC}{LLC }
\newcommand{\LLCfull}{last level cache }
\newcommand{\ie}{i.e., }
\newcommand{\ESSEX}{ESSEX }
\newcommand{\LCCfull}{Low Core Count }
\newcommand{\LCC}{LCC }
\newcommand{\HCCfull}{High Core Count }
\newcommand{\HCC}{HCC }
\newcommand{\MB}{MB }
\newcommand{\KB}{kB }
\newcommand{\GB}{GB }
\newcommand{\TB}{TB }
\newcommand{\SIMD}{SIMD }
\newcommand{\RCMfull}{Reverse Cuthill McKee }
\newcommand{\RCM}{RCM }
\newcommand{\CMfull}{Cuthill McKee }
\newcommand{\BFSfull}{Breadth First Search }
\newcommand{\BFS}{BFS }
\newcommand{\CPU}{CPU }
\newcommand{\pt}{pt. }
\newcommand{\STEX}{2d-7pt stencil }
\newcommand{\Inorder}{In order }
\newcommand{\inorder}{in order }
\newcommand{\levelPtr}{{\tt level\_ptr} }
\newcommand{\atleast}{at least }
\newcommand{\totalLvl}{$total\_level$ }
\newcommand{\totalLvlMATH}{total\_level}
\newcommand{\level}{$level$ }
\newcommand{\levels}{$levels$ }
\newcommand{\levelGroup}{$level \text{  } group$ }
\newcommand{\levelGroups}{$level \text{  } groups$ }
\newcommand{\LevelGroups}{$Level \text{  } groups$ }
\newcommand{\eg}{e.g., }
\newcommand{\subgraph}{sub-graph }
\newcommand{\subgraphs}{sub-graphs }
\newcommand{\levelTree}{{\tt level\_tree} }

\begin{document}

\maketitle

% REQUIRED
\begin{abstract}
  This is an example SIAM \LaTeX\ article. This can be used as a
  template for new articles.  Abstracts must be able to stand alone
  and so cannot contain citations to the paper's references,
  equations, etc.  An abstract must consist of a single paragraph and
  be concise. Because of online formatting, abstracts must appear as
  plain as possible. Any equations should be inline.
\end{abstract}

% REQUIRED
\begin{keywords}
  example, \LaTeX
\end{keywords}

% REQUIRED
\begin{AMS}
  68Q25, 68R10, 68U05
\end{AMS}

\section{Introduction}
The introduction introduces the context and summarizes the
manuscript. It is importantly to clearly state the contributions of
this piece of work. The next two paragraphs are text filler,
generated by the \texttt{lipsum} package.

\lipsum[2-3]

% The outline is not required, but we show an example here.
The paper is organized as follows. Our main results are in
\cref{sec:main}, our new algorithm is in \cref{sec:alg}, experimental
results are in \cref{sec:experiments}, and the conclusions follow in
\cref{sec:conclusions}.

\section{Related Work}
\label{Sec:related_work}
\input{related_work.tex}

\section{Contribution}
\label{Sec:contribution}
\input{contribution.tex}

\section{Test bed, matrices and kernels}
\label{Sec:test_bed}
\input{test_bed_and_others.tex}

\section{Motivation}
\label{Sec:motivation}
\input{motivation.tex}

\section{RACE method}
\label{Sec:race}
\input{race_method.tex}

\section{Experiments and Results}
\label{Sec:expt}
\input{experiment_and_results.tex}

\section{Application Runs}
\label{Sec:appl}

\section{Conclusion}
\label{Sec:conclusion}

\section{Future Work}
\label{Sec:future_work}

\section*{Acknowledgments}
We would like to acknowledge the assistance of volunteers in putting
together this example manuscript and supplement.

\newpage


\bibliographystyle{siamplain}
\bibliography{references}
\newpage


\appendix

\section{Algorithms}
%\subsection{Level Construction}
\begin{algorithm}[htp]
	\caption{Construction of levels}
	\label{alg:BFS}
	\begin{algorithmic}[1]
		\STATE Choose starting node(s) = \{$n$\}
		\STATE $marked\_all$ = false 
		\STATE $N = nrows(graph)$
		\STATE $distFromRoot[1..N] = -1$
		\STATE $curr\_children.push\_back(n)$;
		\STATE $currLvl = 0$
		\WHILE{$!marked\_all$}
		\STATE $marked\_all$ = true
		\STATE $nxt\_children = \{\}$ 
		\FOR{$i=1:size(curr\_children)$}
		\IF{$distFromRoot[curr\_children[i]]==-1$}
		\STATE $distFromRoot[curr\_children[i]]=currLvl$
		\FOR{$j$ in $graph[curr\_children[i]].children$}
		\IF{$distFromRoot[j]==-1$}
		\STATE $nxt\_children.push\_back(j)$
		\ENDIF
		\ENDFOR		
		\ENDIF
		\ENDFOR	
		\STATE $curr\_children = nxt\_children$
		\STATE $currLvl = currLvl + 1$
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}


%\subsection{Load Balancing}\label{alg:LB}
\begin{algorithm}[htp]
	\caption{Load Balancing for two sweep, \DTWO} 
	\label{alg:LB}
	\begin{algorithmic}[1]
		\STATE {$num\_sweep$ = 2 \textcolor{gray}{\hspace{6.3em} \% two sweep method}}
		\STATE {$minGap$ = 2  \textcolor{gray}{\hspace{7.6em} \%\DTWO}}
		\STATE {$len$ = $num\_sweep*nthread$ \textcolor{gray}{\hspace{1em} \% constructing nthread parallel work}}
		\WHILE{$!(exit)$} 
		\STATE\label{lb_line5} {$T\_size$ = update($T\_ptr$) \textcolor{gray}{\hspace{1em} \%$T\_size$ contains non-zeros in each \levelGroup}}
		\STATE {$mean\_r$ = sum($T\_size[0:num\_sweep:len]$) / $nthreads$}
		\STATE {$mean\_b$ = sum($T\_size[1:num\_sweep:len]$) / $nthreads$}
		\STATE {$diff[0:num\_sweep:len]$ = $T\_size[0:num\_sweep:len] .- mean\_r$}
		\STATE {$diff[1:num\_sweep:len]$ = $T\_size[1:num\_sweep:len] .- mean\_b$}
		\STATE\label{lb_line10} {$var$ = dot\_product($diff,diff$)}
		\STATE {$absRankIdx$ = sortIdx(abs($diff$))  \textcolor{gray}{\% sortIdx returns permutation after}}
		\STATE {\textcolor{gray}{\hspace{14.9em} \% sorting from bigger to larger}}
		\STATE {$rankIdx$ = sortIdx($diff$)}
		\STATE {$currRank = 0, newVar = var$}
		\STATE {$old\_T\_ptr$ = $T\_ptr$}
		\WHILE{$newVar \geq var$}
		\STATE {$T\_ptr$ = $old\_T\_ptr$}
		\STATE {$fail$=true}
		\IF{ $diff[absRankIdx[currRank]] < 0$ }
		\FOR{$el$ in $rankIdx[(len-1):-1:0]$}
		\IF{$(T\_Ptr[el+1] - T\_ptr[el]) > min\_gap$}
		\STATE {$acquireIdx$ = el}
		\STATE {$fail$=false}
		\STATE {$break$}
		\ENDIF
		\ENDFOR
		\STATE {shift($T\_ptr, acquireIdx, currRank$) \textcolor{gray}{\% shifts $T\_ptr$ by 1  from  $acquireIdx$}} 
		\STATE {\textcolor{gray} {\hspace{6.5em} \% to $currRank$ if $currIdx < acquireIdx$ else shift by -1}}
		\ELSIF{ $(T\_ptr[currRank+1]-T\_ptr[currRank]) > min\_gap$ }
		\STATE {$giveIdx = rankIdx[0]$}
		\STATE {$fail$=false}
		\STATE {shift($T\_ptr,currRank,giveIdx$)}
		\ENDIF
		\IF{!$fail$}
		\STATE {$newVar$ = calculate\_variance($T\_ptr$) \textcolor{gray}{\% as seen in \textcolor{darkgray}{Line 5} to \textcolor{darkgray}{Line 10}}}
		\ENDIF
		\IF{$ (currRank == (len-1)) \text{  } \&\&  \text{  } (newVar \geq var) $}
		\STATE {$T\_Ptr = old\_T\_ptr$}
		\STATE {$exit$ = true}
		\STATE {$break$}
		\ENDIF
		\STATE {$currRank += 1$}
		\ENDWHILE
		\ENDWHILE
	\end{algorithmic}
\end{algorithm} 
%\lipsum[71]


\end{document}
