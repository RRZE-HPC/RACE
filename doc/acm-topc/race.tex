%%
%% This is file `sample-acmsmall.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.

%\documentclass[format=acmtopc, review=false, screen=true]{acmsmall}
%\documentclass[prodmode,screen=true,acmtopc]{acmsmall} % Aptara syntax
\documentclass[acmsmall]{acmart}
\input{preamble.tex}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
	\providecommand\BibTeX{{%
			\normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

%\copyrightyear{2019}
\acmYear{2019}
\acmDOI{10.1145/1122445.1122456}

% Package to generate and customize Algorithm as per ACM style


% Metadata Information
\acmJournal{TOPC}
\acmVolume{9}
\acmNumber{4}
\acmArticle{39}
\acmYear{XXXX}
\acmMonth{3}



%ISSN
%\issn{1234-56789}

% Document starts
\begin{document}

% Page heads
%\markboth{Christie Alappat et al.}{SymmSpMV with RACE}

% Title portion
\title[SymmSpMV with RACE]{A Recursive Algebraic Coloring Technique for Hardware-Efficient Symmetric Sparse Matrix-Vector Multiplication}

\author{CHRISTIE  ALAPPAT}
\email{christie.alappat@fau.de}
\affiliation{
	\institution{Department for Computer Science, Friedrich-Alexander-Universit\"at Erlangen-N\"urnberg (FAU)}}

\author{GEORG HAGER}
\email{georg.hager@fau.de}
\affiliation{
	\institution{Erlangen Regional Computing Center, Friedrich-Alexander-Universit\"at Erlangen-N\"urnberg (FAU)}}

\author{OLAF SCHENK}
\email{olaf.schenk@usi.ch}
\affiliation{
	\institution{Institute of Computational Science, Universit\`{a} della Svizzera italiana}}

\author{JONAS THIES}
\email{jonas.thies@dlr.de}
\affiliation{
	\institution{Simulation and Software Technology, German Aerospace Center}}

\author{ACHIM BASERMANN}
\email{achim.basermann@dlr.de}
\affiliation{
	\institution{Simulation and Software Technology, German Aerospace Center}}

\author{ALAN R. BISHOP}
\email{arb@lanl.gov}
\affiliation{\institution{Theory, Simulation and Computation, Los Alamos National Laboratory}}

\author{HOLGER FEHSKE}
\email{fehske@physik.uni-greifswald.de}
\affiliation{\institution{Institute of Physics, University of Greifswald}}

\author{GERHARD WELLEIN}
\email{gerhard.wellein@fau.de}
\affiliation{
	\institution{Department for Computer Science, Friedrich-Alexander-Universit\"at Erlangen-N\"urnberg (FAU)}}

% NOTE! Affiliations placed here should be for the institution where the
%       BULK of the research was done. If the author has gone to a new
%       institution, before publication, the (above) affiliation should NOT be changed.
%       The authors 'current' address may be given in the "Author's addresses:" block (below).
%       So for example, Mr. Abdelzaher, the bulk of the research was done at UIUC, and he is
%       currently affiliated with NASA.

% ABSTRACT
\renewcommand{\shortauthors}{Christie Alappat et al.}

\input{abstract.tex}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002950.10003624.10003633.10010917</concept_id>
<concept_desc>Mathematics of computing~Graph algorithms</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Mathematics of computing~Graph algorithms}

%
% End generated code
%

% We no longer use \terms command
%\terms{Design, Algorithms, Performance}

\keywords{sparse matrix, sparse symmetric matrix-Vector multiplication, graph algorithms,  graph coloring, scheduling, memory hierarchies}

\maketitle
%\acmformat{\textcolor{red}{Christie Alappat, Georg Hager, Gerhard Wellein, {and} Olaf Schenk, 2019. A Recursive Algebraic Coloring Technique for Hardware Efficient Symmetric Sparse Matrix-Vector Multiplication.}}
% At a minimum you need to supply the author names, year and a title.
% IMPORTANT:
% Full first names whenever they are known, surname last, followed by a period.
% In the case of two authors, 'and' is placed between them.
% In the case of three or more authors, the serial comma is used, that is, all author names
% except the last one but including the penultimate author's name are followed by a comma,
% and then 'and' is placed before the final author's name.
% If only first and middle initials are known, then each initial
% is followed by a period and they are separated by a space.
% The remaining information (journal title, volume, article number, date, etc.) is 'auto-generated'.


%\maketitle

\section{Introduction and Related Work}
\label{Sec:related_work} 
\input{related_work.tex}

  %\medskip
  
\subsection*{Contribution and Outline}
\label{Sec:contribution}
\input{contribution.tex}


\section{Hardware and Software Environment}
\label{Sec:test_bed}
\input{test_bed_and_others.tex}

\section{Kernels}
\label{Sec:test_kernels}
\input{kernels.tex}

%\subsection{Existing Approaches}
\subsection{Analysis of the \acrshort{SymmSpMV} kernel using parallel coloring schemes for the Spin-26 matrix}
\label{Sec:motivation}
\input{motivation.tex}

\section{Recursive Algebraic Coloring Engine (RACE)}
\label{Sec:race}
\input{race_method.tex}

\section{Parameter study}
\label{Sec:param_study}
\input{parameter_study.tex}

\section{Performance Evaluation of \acrshort{SymmSpMV} using \acrshort{RACE}}
\label{Sec:expt}
\input{experiment_and_results.tex}

\section{Conclusion and Outlook}
\input{conclusion.tex}
\label{Sec:conclusion}

% % Appendix
% \appendix
% \section*{APPENDIX}
% \setcounter{section}{1}
% In this appendix, we measure
% the channel switching time of Micaz [CROSSBOW] sensor devices.
% In our experiments, one mote alternatingly switches between Channels
% 11 and 12. Every time after the node switches to a channel, it sends
% out a packet immediately and then changes to a new channel as soon
% as the transmission is finished. We measure the
% number of packets the test mote can send in 10 seconds, denoted as
% $N_{1}$. In contrast, we also measure the same value of the test
% mote without switching channels, denoted as $N_{2}$. We calculate
% the channel-switching time $s$ as
% \begin{eqnarray}%
% s=\frac{10}{N_{1}}-\frac{10}{N_{2}}. \nonumber
% \end{eqnarray}%
% By repeating the experiments 100 times, we get the average
% channel-switching time of Micaz motes: 24.3$\mu$s.

% \appendixhead{ZHOU}

% % Acknowledgments
\begin{acks}
The project is funded by the German DFG priority programme 1648 ``Software for Exascale Computing (SPPEXA)"
and the Swiss National Science Foundation (SNF)  under the projects ``Dual-Phase Steels - From Micro to Macro Properties (EXASTEEL-2)" (DFG, SNF) and ``Equipping Sparse Solvers for Exascale (ESSEX-II)" (DFG). The authors thank A. Alvermann for providing access to his ScaMac library.  
\end{acks}
\clearpage
\printglossaries
\clearpage


% Bibliography
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}
%\bibliographystyle{plain}


% History dates
%\received{XXXX}{XXXX}{XXXX}

% % Electronic Appendix
% \elecappendix

\medskip

% \section{This is an example of Appendix section head}

% Channel-switching time is measured as the time length it takes for
% motes to successfully switch from one channel to another. This
% parameter impacts the maximum network throughput, because motes
% cannot receive or send any packet during this period of time, and it
% also affects the efficiency of toggle snooping in MMSN, where motes
% need to sense through channels rapidly.

% By repeating experiments 100 times, we get the average
% channel-switching time of Micaz motes: 24.3 $\mu$s. We then conduct
% the same experiments with different Micaz motes, as well as
% experiments with the transmitter switching from Channel 11 to other
% channels. In both scenarios, the channel-switching time does not have
% obvious changes. (In our experiments, all values are in the range of
% 23.6 $\mu$s to 24.9 $\mu$s.)

% \input{Appendix.tex}

\clearpage
\appendix
\begin{comment}
\section{RACE Library}\label{Sec:racelib}
Our method has been implemented and consolidated into a library named \acrshort{RACE}. The library provides an easy interface for parallelizing kernels having dependencies, the user typically just needs to supply a callback function with the serial code (potentially with dependency) and specify the required hardware settings. The library will then parallelize and run the code in parallel. The library is made publicly available through the git repository.

\CAcomm{If necessary description of \acrshort{RACE} library.}
\end{comment}


\section{Algorithms}\label{Sec:algo}
%\subsection{Level Construction}
\begin{algorithm}[htp]
	\caption{Construction of levels}
	\label{alg:BFS}
	\begin{algorithmic}[1]
		\STATE $integer::root = n$ {\textcolor{gray}{\hspace{1em} \% Choose starting node}}
		\STATE $bool::marked\_all = false$ {\textcolor{gray}{\hspace{1em} \% Stopping criteria}}
		\STATE $integer::N = nrows(graph)$
		\STATE $integer::distFromRoot[N] = \{-1\}$
		\STATE $integer::curr\_children[] = \{\}$
		\STATE $curr\_children.push\_back(root)$;
		\STATE $integer::currLvl = 0$
		\WHILE{$!marked\_all$}
		\STATE $marked\_all$ = true
		\STATE $integer::nxt\_children[] = \{\}$ 
		\FOR{$i=1:size(curr\_children)$}
		\IF{$distFromRoot[curr\_children[i]]==-1$}
		\STATE $distFromRoot[curr\_children[i]]=currLvl$
		\FOR{$j$ in $graph[curr\_children[i]].children$}
		\IF{$distFromRoot[j]==-1$}
		\STATE $nxt\_children.push\_back(j)$
		\ENDIF
		\ENDFOR		
		\ENDIF
		\ENDFOR	
		\STATE $curr\_children = nxt\_children$
		\STATE $currLvl = currLvl + 1$
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

%\subsection{Load Balancing}\label{alg:LB}
\begin{algorithm}[htbp]
	\caption{Load Balancing for two sweep, \DTWO, two colors} 
	\label{alg:LB}
	\begin{algorithmic}[1]
		\IF{\cref{subsec:LB}}
		\STATE{$integer::nthreads$ = \acrshort{nthreads}}
		\STATE {$integer::len$ = $2*nthreads$ \textcolor{gray}{\hspace{1em} \% number of \levelGroups}}
		\STATE{$integer::worker[len] = {1}$}
		\STATE{$integer::T\_ptr[len+1] = linspace(0, \acrshort{totalLvl}, len) $ \textcolor{gray}{\hspace{0em} \% \levelGroup pointer}}
		\ELSE
		\STATE{$integer::nthreads = n_t(T_{s-1}(i))$ \textcolor{gray}{\% $i$ is the index of \levelGroup in stage $s-1$}}
		\STATE{\textcolor{gray}{\hspace{15em}\% where recursion is applied.}}
		\STATE {$integer::len$ = $2*nthreads$ \textcolor{gray}{\hspace{1.5em} \% number of \levelGroups}}
		\STATE{$integer::worker[len] = [n_t(T_{s}(0)), ... ,n_t(T_{s}(len-1))] = b$}
		\STATE{$integer::T\_ptr[len+1] = linspace(0, \acrshort{totalLvl}, len) $}
		\ENDIF	
		\STATE{$bool::exit = false$}
		\STATE{$integer::T\_size[len], absRankIdx[len], rankIdx[len], currRank$}
		\STATE{$double::mean\_r, mean\_b, diff[len], var, newVar$}
		\WHILE{$!(exit)$} 
		\STATE\label{lb_line5} {$T\_size[:]$ = update($T\_ptr[:]$) \textcolor{gray}{\hspace{0em} \% $T\_size$ contains nrows in each \levelGroup}}
		\STATE {$integer::T\_size\_worker[:]$ = $T\_size[:]/worker[:]$} 
		\STATE {$mean\_r$ = sum($T\_size\_worker[0:2:len-1]$) / $nthreads$}
		\textcolor{gray}{\%mean of red color}
		\STATE {$mean\_b$ = sum($T\_size\_worker[1:2:len-1]$) / $nthreads$}
		\textcolor{gray}{\%mean of blue color}
		\STATE {$diff[0:2:len-1]$ = $T\_size\_worker[0:2:len-1] .- mean\_r$}
		\STATE {$diff[1:2:len-1]$ = $T\_size\_worker[1:2:len-1] .- mean\_b$}
		\STATE\label{lb_line10} {$var$ = dot\_product($diff,diff$)/len} \textcolor{gray}{\% overall variance}
		\STATE {$absRankIdx$ = argsort(-abs($diff$))  \textcolor{gray}{\% ranking according to absolute deviation}}
		\STATE {$rankIdx$ = argsort($diff$)} \textcolor{gray}{\% ranking according to signed deviation}
	%	\STATE { \textcolor{gray}{\% ,to find the order of \levelGroups from/to which levels have to be acquired/added}}
		\STATE {$currRank = 0, newVar = var$}
		\STATE {$integer::old\_T\_ptr[len+1]$ = $T\_ptr[:], acquireIdx, giveIdx$}
		\WHILE{$newVar \geq var$}
		\STATE {$T\_ptr$ = $old\_T\_ptr$}
		\STATE {$bool::fail$=true}
		\IF{ $diff[absRankIdx[currRank]] < 0$ }
		\FOR{$el$ in $rankIdx[(len-1):-1:0]$}
		\IF{$(T\_Ptr[el+1] - T\_ptr[el]) > 2$}
		\STATE {$acquireIdx$ = el}
		\STATE {$fail$=false}
		\STATE {$break$}
		\ENDIF
		\ENDFOR
		\STATE {shift($T\_ptr, acquireIdx, currRank$) \textcolor{gray}{\% shifts $T\_ptr$ by 1  from  $acquireIdx$}} 
		\STATE {\textcolor{gray} {\hspace{6.5em} \% to $currRank$ if $currIdx < acquireIdx$ else shift by -1}}
		\ELSIF{ $(T\_ptr[currRank+1]-T\_ptr[currRank]) > 2$ }
		\STATE {$giveIdx = rankIdx[0]$}
		\STATE {$fail$=false}
		\STATE {shift($T\_ptr,currRank,giveIdx$)}
		\ENDIF
		\algstore{lbAlg}
	\end{algorithmic}
\end{algorithm} 


\begin{algorithm}
	\begin{algorithmic}	
		\algrestore{lbAlg}
		\IF{!$fail$}
		\STATE {$newVar$ = calculate\_variance($T\_ptr$) \textcolor{gray}{\% as seen in \textcolor{darkgray}{Line 17} to \textcolor{darkgray}{Line 23}}}
		\ENDIF
		\IF{$ (currRank == (len-1)) \text{  } \&\&  \text{  } (newVar \geq var) $}
		\STATE {$T\_Ptr = old\_T\_ptr$}
		\STATE {$exit$ = true}
		\STATE {$break$}
		\ENDIF
		\STATE {$currRank += 1$}
		\ENDWHILE
		\ENDWHILE
	\end{algorithmic}
\end{algorithm} 

%\lipsum[71]

\end{document}
